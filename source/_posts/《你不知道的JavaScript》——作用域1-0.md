---
title: 《你不知道的JavaScript》——作用域1.0
date: 2017-04-25 19:14:26
tags: JavaScript
categories: 前端
---
##### 作用域理解
##### 参与者
+ 引擎：负责整个JavaScript程序的编译和执行过程
+ 编译器：负责语法分析以及代码生成
+ 作用域：负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。

<!-- more -->

##### 对于 var a = 2;
+ 会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明），然后再运行时引擎会在作用域中查找该变量，如果能找到就对其赋值。
##### RHS和LHS
+ RHS查询：与简单的查询某个变量的值差不多。
+ LHS查询：会试图找到变量容器的本身。
```
    function foo(a){
        console.log(a); //2
    }
    foo(2);
```
+ 对于最后一行的foo(...)函数的调用是对foo进行RHS引用，意味着“去找到foo的值，并把它给我”
+ 代码中隐式的a=2操作， 这个操作发生在2被当做参数传递给foo(...)函数时，2会被分配给a。进行了一次LHS查询。

##### 异常
```
    function foo(a){
         console.log(a+b);
         b=a;
    }
    foo(2);
```
+ 第一次对b进行RHS查询是无法找到该变量的。如果RHS查询在所有嵌套作用域中都找不到所需的变量，引擎会抛出ReferenceError异常
+ 当引擎进行LHS查询时，如果在全局作用域中也无法找到目标变量，全局作用域中会创建一个具有该名称的变量（非严格模式下）。严格模式下，LHS查询失败时，引擎会抛出与RHS查询失败时类似的ReferenceError异常。
+ 如果RHS查询找到了一个变量，但如果对其的值进行不合理操作，引擎会抛出TypeError异常。

#### 词法作用域
词法作用域是由你在写代码时将变量和块作用域写在哪决定的。
##### 查找
+ 作用域查找会在找到第一个匹配的标识符时停止。作用域查找始终从运行时所处的最内部作用域开始，逐级往上进行，直到遇到第一个匹配的标识符。
+ 词法作用域只会查找一级标识符，比如a、b和c。如果代码中引用了foo.bar.baz，词法作用域查找只会试图查找foo标识符，找到变量后，对象属性访问规则会分别接管对bar和baz属性的访问。

##### 欺骗词法
+ 词法作用域完全由写代码期间函数所声明的位置来定义，JavaScript可以有两种机制在运行时来欺骗词法作用域。
+ 欺骗词法作用域会导致性能下降

###### eval
```
    function foo(str,a){
        eval(str); //欺骗
        console.log(a,b);
    }
    var b = 2;
    foo("var b = 3",1); //1,3

```
+ eval(...)调用中的“var b=3”会被当做本来就在那里一样处理。由于里面声明了一个新的变量b，因此它对已经存在的foo(...)的词法作用域进行修改。这段代码在foo()的内部创建了一个变量b，并遮蔽了外部作用域中的同名变量。
+ 无论任何情况，eval()都可以在运行期修改书写期的词法作用域。
+ 但在严格模式下，eval在运行时有其自己的词法作用域，意味着其中的声明无法修改所在作用域，在上面的代码上来看，会进行报错。

###### with
with可以不需要重复引用对象本身
```
    var obj={
        a:1,
        b:2,
        c:3
    };
    obj.a=2;
    obj.b=3;
    obj.c=4;
    //with
    with(obj){
        a=3;
        b=4;
        c=5;
    }
```
对于以下代码
```
    function foo(obj){
        with(obj){
            a=2;
        }
    }
    var o1 = {
        a:3
    };
    var o2 = {
        b:3
    };
    
    foo(o1);
    console.log(o1.a); //2
    
    foo(o2);
    console.log(o2.a); //undefined
    console.log(a); //2  a被泄露到全局作用域上了
```
+ with可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符。
+ 尽管with块可以将一个对象处理为词法作用域，但是这个块内部正常的var声明并不会被限制在这个块的作用域中，而是被添加到with所处的函数作用域中。
+ o2的作用域，foo()的作用域和全局作用域中都没有找到标识符a,因此当a=2执行时，会自动创建一个全局变量（非严格）

###### eval和with
+ eval函数如果接受了含有一个或多个声明的代码，就会修改其所处的词法作用域，而with声明实际上是根据你传递给他的对象凭空创建一个全新的词法作用域。
+ eval和with都会被严格模式所影响
+ 当引擎在代码中发现eval或with，它只能简单的假设关于标识符位置的判断都是无效的，无法在词法分析阶段明确知道eval会接收什么代码，也不知道传递给with的到底是什么。
+ 如果代码中大量使用eval或with，运行会很慢。 
+ 不使用这两个机制