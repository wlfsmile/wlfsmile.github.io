{"meta":{"title":"wlfsmile的博客","subtitle":"水满则溢，月盈则亏","description":"水满则溢，月盈则亏","author":"wlfsmile","url":"http://wlfsmile.win"},"pages":[{"title":"","date":"2017-08-06T13:49:30.692Z","updated":"2017-08-06T13:49:30.688Z","comments":true,"path":"baidu_verify_474YWYLrcv.html","permalink":"http://wlfsmile.win/baidu_verify_474YWYLrcv.html","excerpt":"","text":"474YWYLrcv"},{"title":"about","date":"2017-01-16T10:18:21.000Z","updated":"2017-08-14T11:08:21.113Z","comments":true,"path":"about/index.html","permalink":"http://wlfsmile.win/about/index.html","excerpt":"","text":"吴林霏 就读于重庆邮电大学 一名大二的小白 正在学习关于前端的技术知识 希望之后会越来越好 一个完全被汉化的苗族妹纸 爱自己，爱生活 努力学习 做好自己 爱我所爱 做我所爱做的事"},{"title":"categories","date":"2017-08-14T11:03:38.000Z","updated":"2017-08-14T11:45:32.924Z","comments":false,"path":"categories/index.html","permalink":"http://wlfsmile.win/categories/index.html","excerpt":"","text":""},{"title":"project","date":"2017-08-06T07:29:44.000Z","updated":"2017-08-06T07:30:12.685Z","comments":false,"path":"project/index.html","permalink":"http://wlfsmile.win/project/index.html","excerpt":"","text":""},{"title":"search","date":"2017-08-06T07:30:28.000Z","updated":"2017-08-06T07:30:49.397Z","comments":false,"path":"search/index.html","permalink":"http://wlfsmile.win/search/index.html","excerpt":"","text":""},{"title":"tag","date":"2017-08-06T07:25:08.000Z","updated":"2017-08-06T07:25:42.699Z","comments":false,"path":"tag/index.html","permalink":"http://wlfsmile.win/tag/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-01-16T04:46:09.000Z","updated":"2017-08-14T11:45:47.327Z","comments":false,"path":"tags/index.html","permalink":"http://wlfsmile.win/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"使用Node.js+Express 简易开发服务端实例","slug":"使用Node-js-Express-简易来发服务端实例","date":"2017-08-14T06:48:29.000Z","updated":"2017-08-14T12:58:37.327Z","comments":true,"path":"year/08/14/使用Node-js-Express-简易来发服务端实例/","link":"","permalink":"http://wlfsmile.win/year/08/14/使用Node-js-Express-简易来发服务端实例/","excerpt":"本文主要写的是用NodeJS+Express进行的一个服务端的建议开发","text":"本文主要写的是用NodeJS+Express进行的一个服务端的建议开发 本文主要摘自使用 NodeJS+Express 开发服务端github代码地址：demo 环境配置要求 安装Node.js环境，具体方法不做细说，可参考阮一峰的官方网站 安装express(都为全局安装)，npm有时候太慢，可安装淘宝镜像cnpm 12npm install express -gnpm install express-generator -g 初始化项目 12cd 你的文件目录express 项目名称（我设为APIServer） 得到的目录结构如下 + /bin:用来启动应用（服务器） /public: 存放静态资源目录 /routes：路由用于确定应用程序如何响应对特定端点的客户机请求，包含一个URI（或路径）和一个特定的 HTTP 请求方法（GET、POST等）。每个路由可以具有一个或多个处理程序函数，这些函数在路由匹配时执行 /views: 模板文件所在目录 文件格式为.jade 目录app.js程序main文件 这个是服务器启动的入口 启动服务器在终端最后的位置输出了如下两个命令12345install dependencies: $ cd APIServer &amp;&amp; npm install //进入项目并安装环境run the app: $ DEBUG=apiserver:* npm start //启动服务器 启动服务器 1npm start +在浏览器中访问http://localhost:3000/ 基本使用 app.js 123456789101112131415161718192021var express = require(&apos;express&apos;);var path = require(&apos;path&apos;);var favicon = require(&apos;serve-favicon&apos;);var logger = require(&apos;morgan&apos;);var cookieParser = require(&apos;cookie-parser&apos;);var bodyParser = require(&apos;body-parser&apos;);var app = express();///=======路由信息 （接口地址）开始 存放在./routes目录下===========//var routes = require(&apos;./routes/index&apos;);//home page接口var users = require(&apos;./routes/users&apos;); //用户接口app.use(&apos;/&apos;, routes); //在app中注册routes该接口 app.use(&apos;/users&apos;, users);//在app中注册users接口///=======路由信息 （接口地址 介绍===========/////=======模板 开始===========//// view engine setupapp.set(&apos;views&apos;, path.join(__dirname, &apos;views&apos;));app.set(&apos;view engine&apos;, &apos;jade&apos;);///=======模板 结束===========// index.js 1234567891011var express = require(&apos;express&apos;);var router = express.Router();//定义一个get请求 path为根目录/* GET home page. */router.get(&apos;/&apos;, function(req, res, next) &#123; res.render(&apos;index&apos;, &#123; title: &apos;Express&apos; &#125;);&#125;);module.exports = router; 定义一个路由的基本格式为1app.METHOD(PATH, HANDLER) 其中 app: express的实例 METHOD: HTTP 请求方法(get/post之类)。 PATH: 服务器上的路径。 HANDLER: 在路由匹配时执行的函数。 简单实现一个获取用户信息接口 创建一个user.js文件,/routes/user.js 定义一个User模型 123456function User()&#123; this.name; this.city; this.age;&#125;module.exports = User; 切换到users.js头部添加 12var URL = require(&apos;url&apos;); //请求url模块var User = require(&apos;./user&apos;); //引入user.js 并继续添加1234567891011121314151617router.get(&apos;/getUserInfo&apos;,function(req,res,next)&#123; var user = new User(); var params = URL.parse(req.url,true).query; if(params.id == &apos;1&apos;)&#123; user.name = &quot;ligh&quot;; user.age = &quot;1&quot;; user.city = &quot;北京市&quot;; &#125;else&#123; user.name = &quot;SPTING&quot;; user.age = &quot;1&quot;; user.city = &quot;杭州市&quot;; &#125; var response = &#123;status:1,data:user&#125;; res.send(JSON.stringify(response));&#125;) 其中12获取url参数 依赖于url模块 使用前需要使用 require(&apos;url&apos;)var params = URL.parse(req.url, true).query; 由于users.js路由信息已经在app.js注册停止服务器 重新start服务器即可直接访问 调用方式http://localhost:3000/users/getUserInfo?id=1或者http://localhost:3000/users/getUserInfo?id=2 注意我们访问的方式为users/getUserInfo?id=1 而不是基于根原因是我们在app.js注册方式为app.use(‘/users’, users);我们可以利用这种方式 开发模块功能 比如 你有另外一个模块为msg我们注册为：app.use(‘/msgs’, msgs);调用方式为http://localhost:3000/msgs/getUserMsgs?id=1","categories":[{"name":"Node","slug":"Node","permalink":"http://wlfsmile.win/categories/Node/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://wlfsmile.win/tags/node-js/"},{"name":"express","slug":"express","permalink":"http://wlfsmile.win/tags/express/"}]},{"title":"redux学习笔记——简易开发步骤","slug":"redux学习笔记——简易开发步骤","date":"2017-07-10T07:18:40.000Z","updated":"2017-07-10T13:41:32.923Z","comments":true,"path":"year/07/10/redux学习笔记——简易开发步骤/","link":"","permalink":"http://wlfsmile.win/year/07/10/redux学习笔记——简易开发步骤/","excerpt":"这篇文章主要是写我一开始学习redux的开发的步骤，比较适合刚刚入门的小白，不知道怎么开始下手代码,本篇文章以计数器为例。本篇文章参考Redux学习笔记：Redux简易开发步骤github代码地址react-redux-counter","text":"这篇文章主要是写我一开始学习redux的开发的步骤，比较适合刚刚入门的小白，不知道怎么开始下手代码,本篇文章以计数器为例。本篇文章参考Redux学习笔记：Redux简易开发步骤github代码地址react-redux-counter 项目结构1234567891011121314.├─.babelrc // babel的配置├─.gitignore // git忽略上传的文件├─package.json // npm命令包├─readme.md // 项目介绍├─node_modules├─public // 展示页面html入口| └index.html├─src | ├─components // react component| | ├─Counter.js| ├─reducers| | ├─index.js // 操作信息并改变state| └index.js // 主文件js 步骤 index.js(主文件js) 定义render入口并调用Counter 12345678const render = () =&gt; ReactDOM.render( &lt;Counter value=&#123;&#125; onIncrement=&#123;&#125; onDecrement=&#123;&#125; /&gt;, document.getElementById(&apos;root&apos;)) 定义Counter，也就是React Component，生成DOM结构，render时触发。 1234567891011121314151617181920212223242526272829import React,&#123;Component&#125; from &apos;react&apos;;import &#123;render&#125; from &apos;react-dom&apos;;class Counter extends Component&#123; constructor(props) &#123; super(props); &#125; render()&#123; const &#123;value,onDecrement,onIncrement&#125; = this.props; return( &lt;p&gt; Clicked: &#123;value&#125; times &#123;&apos; &apos;&#125; &lt;button onClick=&#123;onIncrement&#125;&gt; + &lt;/button&gt; &#123;&apos; &apos;&#125; &lt;button onClick=&#123;onDecrement&#125;&gt; - &lt;/button&gt; &lt;/p&gt; ); &#125;&#125;export default Counter; 初始化显示，手动调用render()，第一次初始化时定义，后续不在执行 1render(); 创建store，并绑定reducer 1const store = createStore(reducer); // createStore的第一个参数必须是个函数，store.dispatch()时执行，该函数就叫reducer 定义Action，调用store.dispatch 12345678910const render = () =&gt; ReactDOM.render( &lt;Counter value=&#123;store.getState()&#125; onIncrement=&#123;() =&gt; store.dispatch(&#123; type: &apos;INCREMENT&apos; &#125;)&#125; onDecrement=&#123;() =&gt; store.dispatch(&#123; type: &apos;DECREMENT&apos; &#125;)&#125; /&gt;, rootEl)render() 定义Reducer，生成新的state(reducer/index.js) 12345678910export default (state = 0, action) =&gt; &#123; switch (action.type) &#123; case &apos;INCREMENT&apos;: return state + 1 case &apos;DECREMENT&apos;: return state - 1 default: return state &#125;&#125; 定义state变化监听(index.js主文件) 1store.subscribe(render)","categories":[],"tags":[]},{"title":"函数作用域和块作用域","slug":"函数作用域和块作用域","date":"2017-04-27T08:30:43.000Z","updated":"2017-04-27T08:39:48.845Z","comments":true,"path":"year/04/27/函数作用域和块作用域/","link":"","permalink":"http://wlfsmile.win/year/04/27/函数作用域和块作用域/","excerpt":"这篇总结主要摘自《你不知道的JavaScript》上卷。也是我对这一部分的总结这部分的知识点我并未完全总结，主要是一些平时常用或者易错点","text":"这篇总结主要摘自《你不知道的JavaScript》上卷。也是我对这一部分的总结这部分的知识点我并未完全总结，主要是一些平时常用或者易错点 函数作用域 每声明一个函数，都会为其自身创建一个气泡。 隐藏内部实现 我们可以将函数理解为先声明一个函数，再为其添加代码。也可以理解为先写代码，再用函数声明进行包装。后者就是所谓的“隐藏”，将变量隐藏在函数声明里面 最小授权/暴露原则：在软件设计中，最小限度地暴露必要内容，而将其他内容都隐藏起来。 作用 避免同名标识符之间的冲突 匿名和具名 如果function是声明中的第一个词，那么就是一个函数声明。否则就是一个函数表达式。 函数表达式可以是匿名的，函数声明不可以省略函数名。 匿名函数的弊端 在栈追踪中不会显示出有意义的函数名，使得调试困难 函数引用自身时不方便，只能使用过期的argument.callee引用 降低代码的可读性和可理解性 解决方法：行内函数表达式1234567setTimeout(function()&#123; console.log(&quot;111&quot;);&#125;,1000);//改为行内函数表达式setTimeout(function timeoutHandler()&#123; console.log(&quot;111&quot;);&#125;,1000); 立即执行函数表达式123456var a = 2;(function foo()&#123; var a = 3; console.log(a); //3&#125;)();console.log(a); //2 (function foo(){…})()，第一个()将函数变成表达式，第二个()执行了这个函数 IIFE：代表立即执行函数表达式 另一种用法：(function(){}())。两种形式功能一样 IIFE的一些用法 把他们当做函数调用并传递参数进去 1234567var a = 2;(function IIFE(global)&#123; var a = 3; console.log(a); //3 console.log(global.a); //2&#125;)(window);console.log(a); //2 解决undefined标识符的默认值被错误覆盖引发的异常（少见） 1234567undefined = true; //bug(function IIFE(undefined)&#123; var a; if(a === undefined)&#123; console.log(&quot;undefined is safe here!&quot;); &#125;&#125;)(); 倒置代码的运行顺序 12345678var a = 2;(function IIFE(def)&#123; def(window)l&#125;)(function def(global)&#123; var a = 3; console.log(a); //3 console.log(global.a); //2&#125;); 将需要运行的函数放在第二位，在IIFE执行之后当做参数传递进去 先执行def,在将window当做参数传入def 块作用域123for(var i=0;i&lt;10;i++)&#123; console.log(i);&#125; 以上代码中的i会被绑定在外部作用域（函数或全局）中 块作用域是一个用来对最小授权原则进行扩展的工具，将代码从在函数中隐藏信息扩展为在块中隐藏信息方案withtry/catch try/catch的catch分句会创建一个块作用域，其中声明的变量仅在catch内部有效1234567try&#123; undefined();&#125;catch(err)&#123; console.log(err); //正常运行&#125;console.log(err); //RefrenceError : err not found let ES6引入了新的let关键字。可以绑定到所在的任何作用域中。let为其声明的变量隐式的劫持了所在的块作用域 为块作用域显示创建块——在声明中的任意位置都可以使用{}来为let创建一个用于绑定的块 let进行的声明不会在块作用域中进行提升 垃圾收集123456789function process(data)&#123; //...&#125; var someReallyBigData = &#123;...&#125;;process(someReallyBigData);var btn = document.getElementById(&quot;my_button&quot;);btn.addEventListener(&quot;click&quot;,function click(evt)&#123; console.log(&quot;button clicked&quot;);&#125;,/**/false); click函数点击回调并不需要someReallyBigData变量。但是当process执行后，其并不一定被垃圾回收了。由于click函数形成了一个覆盖整个作用域的闭包，JavaScript引擎极可能保存着这个结构。 块作用域用来解决 123456789101112function process(data)&#123; //...&#125;//这个块定义的内容完事可以销毁&#123; let someReallyBigData = &#123;...&#125;; process(someReallyBigData);&#125;var btn = document.getElementById(&quot;my_button&quot;);btn.addEventListener(&quot;click&quot;,function click(evt)&#123; console.log(&quot;button clicked&quot;);&#125;,/**/false); let循环 1234for(let i=0;i&lt;10;i++)&#123; console.log(i);&#125;console.log(i); //ReferenceError for循环头部的let将i绑定到了for循环的块中。也将其重新绑定到了循环的每一次迭代中，确保使用上一次循环迭代结束时的值重新进行赋值。 const const可以用来创建块作用域，但其值是固定的（常量）。不可修改123456789var foo = true;if(foo)&#123; var a = 2; const b = 3; // 包含在if中的块作用域常量 a = 3; // 正常 b = 4; // 错误&#125;console.log(a); //3console.log(b); //ReferenceError 附加 引擎会在解释JavaScript代码之前首先对其进行编译，编译阶段会找到所有的声明，并用合适的作用域将他们关联起来。 所有声明（变量、函数）都会在任何代码被执行前首先被处理先声明后赋值 只有声明本身会被提升，赋值或其他运行逻辑会留在原地12console.log(a);var a = 2; 会被解读为123var a;console.log(a); //undefineda = 2; 函数声明会被提升，但是函数表达式却不会被提升 即使是具名的函数表达式，名称在标识符赋值之前也无法在所在作用域中使用12345foo(); //TypErrorbar(); //ReferenceErrorvar foo= funcion bar()&#123; //...&#125;; 会被解读为123456var foo;foo(); //TypErrorbar(); //ReferenceErrorfoo= funcion bar()&#123; //...&#125;; 函数优先 函数声明和变量声明都会被提升，函数会首先被提升，然后才是变量12345678foo(); //1var foo;function foo()&#123; console.log(1);&#125;foo = function()&#123; console.log(2);&#125;; 会被引擎理解为1234567function foo()&#123; console.log(1);&#125;foo(); //1foo = function()&#123; console.log(2);&#125;; 虽然var foo出现在function foo()的声明之前，但是他是重复声明，所以被忽略了。函数声明会被提升到普通变量之前。 后面的函数声明可以覆盖前面的函数声明。 一个普通块内部的函数声明通常会被提升到所在作用域顶部，避免在块内部声明函数123456789foo(); //bvar a = true;if(a)&#123; function foo()&#123; console.log(&quot;a&quot;); &#125;&#125;else&#123; console.log(&quot;b&quot;);&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://wlfsmile.win/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wlfsmile.win/tags/JavaScript/"}]},{"title":"《你不知道的JavaScript》——作用域1.0","slug":"《你不知道的JavaScript》——作用域1-0","date":"2017-04-25T11:14:26.000Z","updated":"2017-04-25T11:22:48.283Z","comments":true,"path":"year/04/25/《你不知道的JavaScript》——作用域1-0/","link":"","permalink":"http://wlfsmile.win/year/04/25/《你不知道的JavaScript》——作用域1-0/","excerpt":"作用域理解参与者 引擎：负责整个JavaScript程序的编译和执行过程 编译器：负责语法分析以及代码生成 作用域：负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。","text":"作用域理解参与者 引擎：负责整个JavaScript程序的编译和执行过程 编译器：负责语法分析以及代码生成 作用域：负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。 对于 var a = 2; 会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明），然后再运行时引擎会在作用域中查找该变量，如果能找到就对其赋值。RHS和LHS RHS查询：与简单的查询某个变量的值差不多。 LHS查询：会试图找到变量容器的本身。 1234function foo(a)&#123; console.log(a); //2&#125;foo(2); 对于最后一行的foo(…)函数的调用是对foo进行RHS引用，意味着“去找到foo的值，并把它给我” 代码中隐式的a=2操作， 这个操作发生在2被当做参数传递给foo(…)函数时，2会被分配给a。进行了一次LHS查询。 异常12345function foo(a)&#123; console.log(a+b); b=a;&#125;foo(2); 第一次对b进行RHS查询是无法找到该变量的。如果RHS查询在所有嵌套作用域中都找不到所需的变量，引擎会抛出ReferenceError异常 当引擎进行LHS查询时，如果在全局作用域中也无法找到目标变量，全局作用域中会创建一个具有该名称的变量（非严格模式下）。严格模式下，LHS查询失败时，引擎会抛出与RHS查询失败时类似的ReferenceError异常。 如果RHS查询找到了一个变量，但如果对其的值进行不合理操作，引擎会抛出TypeError异常。 词法作用域词法作用域是由你在写代码时将变量和块作用域写在哪决定的。 查找 作用域查找会在找到第一个匹配的标识符时停止。作用域查找始终从运行时所处的最内部作用域开始，逐级往上进行，直到遇到第一个匹配的标识符。 词法作用域只会查找一级标识符，比如a、b和c。如果代码中引用了foo.bar.baz，词法作用域查找只会试图查找foo标识符，找到变量后，对象属性访问规则会分别接管对bar和baz属性的访问。 欺骗词法 词法作用域完全由写代码期间函数所声明的位置来定义，JavaScript可以有两种机制在运行时来欺骗词法作用域。 欺骗词法作用域会导致性能下降 eval123456function foo(str,a)&#123; eval(str); //欺骗 console.log(a,b);&#125;var b = 2;foo(&quot;var b = 3&quot;,1); //1,3 eval(…)调用中的“var b=3”会被当做本来就在那里一样处理。由于里面声明了一个新的变量b，因此它对已经存在的foo(…)的词法作用域进行修改。这段代码在foo()的内部创建了一个变量b，并遮蔽了外部作用域中的同名变量。 无论任何情况，eval()都可以在运行期修改书写期的词法作用域。 但在严格模式下，eval在运行时有其自己的词法作用域，意味着其中的声明无法修改所在作用域，在上面的代码上来看，会进行报错。 withwith可以不需要重复引用对象本身1234567891011121314var obj=&#123; a:1, b:2, c:3&#125;;obj.a=2;obj.b=3;obj.c=4;//withwith(obj)&#123; a=3; b=4; c=5;&#125; 对于以下代码123456789101112131415161718function foo(obj)&#123; with(obj)&#123; a=2; &#125;&#125;var o1 = &#123; a:3&#125;;var o2 = &#123; b:3&#125;;foo(o1);console.log(o1.a); //2foo(o2);console.log(o2.a); //undefinedconsole.log(a); //2 a被泄露到全局作用域上了 with可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符。 尽管with块可以将一个对象处理为词法作用域，但是这个块内部正常的var声明并不会被限制在这个块的作用域中，而是被添加到with所处的函数作用域中。 o2的作用域，foo()的作用域和全局作用域中都没有找到标识符a,因此当a=2执行时，会自动创建一个全局变量（非严格） eval和with eval函数如果接受了含有一个或多个声明的代码，就会修改其所处的词法作用域，而with声明实际上是根据你传递给他的对象凭空创建一个全新的词法作用域。 eval和with都会被严格模式所影响 当引擎在代码中发现eval或with，它只能简单的假设关于标识符位置的判断都是无效的，无法在词法分析阶段明确知道eval会接收什么代码，也不知道传递给with的到底是什么。 如果代码中大量使用eval或with，运行会很慢。 不使用这两个机制","categories":[{"name":"前端","slug":"前端","permalink":"http://wlfsmile.win/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://wlfsmile.win/tags/JavaScript/"}]},{"title":"深入react技术栈-2","slug":"深入react技术栈-2","date":"2017-04-10T12:31:30.000Z","updated":"2017-04-10T12:36:16.701Z","comments":true,"path":"year/04/10/深入react技术栈-2/","link":"","permalink":"http://wlfsmile.win/year/04/10/深入react技术栈-2/","excerpt":"第一章（Raact数据流、React生命周期、React与DOM）React数据流在React中，数据是自项向下单向流动的。即从父组件到子组件。 如果顶层组件初始化props，那么React会向下遍历整棵组件树，重新尝试渲染所有相关的子组件。而state只关心每个组件自己的内部的状态，这些状态只能在组件内改变。","text":"第一章（Raact数据流、React生命周期、React与DOM）React数据流在React中，数据是自项向下单向流动的。即从父组件到子组件。 如果顶层组件初始化props，那么React会向下遍历整棵组件树，重新尝试渲染所有相关的子组件。而state只关心每个组件自己的内部的状态，这些状态只能在组件内改变。 state 当组件内部使用库内置的setState方法时，最大的表现行为就是该组合会尝试重新渲染。1234567891011121314151617181920212223import React,&#123;Component&#125; form &apos;react&apos;;class Counter extends Component&#123; constructor(pros)&#123; super(props); this.state = &#123; count:0, &#125;; &#125; handleClick(e)&#123; e.preventDefault(); this.setState(&#123; count : this.state.count + 1, &#125;); &#125; render()&#123; renturn( &lt;div&gt; &lt;p&gt;&#123;this.state.count&#125;&lt;/p&gt; &lt;a href=&quot;#&quot; onClick=&#123;this.handleClick&#125;&gt;更新&lt;/a&gt; &lt;/div&gt; ); &#125;&#125; 上述例子是通过点击“更新”按钮不断的更新内部值。把组件内状态封装在现实中。 setState 是一个异步方法。一个生命周期内所有的setState方法会合并操作。 props 是react用来让组件之间相互联系的一种机制。 react的单向数据流，主要的流动管道是props。其本身不可变的，组件的props一定来自默认属性或者通过父组件传递而来。 组件的部分props className：根节点的class。 classPrefix：class的统一前缀。有助于对样式与交互分离。 defaultActiveIndex和activeIndex：默认的激活索引。 onChange：回调函数。一般与activeIndex搭配使用。 react为props提供了默认配置，可通过defaultProps静态变量的方式定义。 1234static defaultProps =&#123; classPrefix:&apos;&apos;, onChange:()=&gt;&#123;&#125;,&#125;; 子组件prop 在react中有一个重要且内置的prop——children，代表组件的子组件集合。 React.Children是React官方提供的一系列操作children的方法。提供诸如map、forEach、count等实用函数。 组件props 用function prop与父组件通信 对于state，它的通信集中在组件内部。对于props，它的通信是父组件向子组件的传播。 propType 用于规范props的类型与必需的状态。若组件定义了propType，那么在开发环境下，就会对组件的props值的类型作检查。 React生命周期 react组件的生命周期分为挂载、渲染和卸载。 挂载或卸载过程 组件的挂载 主要做组件状态的初始化123456789101112131415161718192021222324import React,&#123;Component,PropTypes&#125; form &apos;react&apos;;class App extends Component&#123; static propTypes=&#123; //... &#125;; static defaultProps=&#123; //... &#125;; constructor(props)&#123; super(props); this.state=&#123; //... &#125;; &#125; componentWillMount()&#123; //... &#125; componentDidMount()&#123; //... &#125; render()&#123; return &lt;div&gt;This is a demo.&lt;/div&gt;; &#125;&#125; 两个生命周期方法 componentWillMount，在render方法之前执行。（渲染前） componentDidMount，在render方法之后执行。（渲染后） 执行setState方法 在componentWillMount中，组件会更新state，但组件只渲染一次。无意义的执行 在componentDidMount中，组件会再次更新，在初始化过程中就渲染了两次。 组件的卸载 只有componentWillMount这一个卸载前状态。 数据更新过程 指的是父组件向下传递props或组件自身执行setState方法时发生的一系列更新动作。 123456789101112131415161718import React,&#123;Component,PropTypes&#125; from &apos;react&apos;;class App extends Component&#123; componentWillReceiveProps(nextProps)&#123; //this.setState(&#123;&#125;) &#125; shouldComponentUpdate(nextProps,nextState)&#123; //... &#125; componentWillUpdate(nextProps,nextState)&#123; //... &#125; componentDidUpdate(prevProps,prevState)&#123; //... &#125; render()&#123; return &lt;div&gt;This is a demo.&lt;/div&gt; &#125;&#125; 组件自身的state更新，会依次执行shouldComponentUpdate、componentWillUpdate、rebder和componentDidUpdate。 shouldComponentUpdate 接收需要更新的props和state。开发者加入必要的条件判断，当方法返回false，组件不再向下执行生命周期方法。 componentWillUpdate方法提供需要更新的props和state，代表更新过程中渲染前时刻；componentDidUpdate方法提供更新前的props和state，代表更新过程中渲染后时刻。 如果组件是由父组件更新props而更新的，那么在shouldComponentUpdate之前会先执行componentWillReceiveProps方法。在此方法中调用setState不会有二次渲染。 React与DOM 在组件开实现中，不会用到ReactDOM，只有在顶层组件以及由于React模型所限而不得不操作DOM的时候，才会用。 ReactDOM findDOMNode React提供的获取DOM元素的方法。 1DOMElement findDOMNode(ReactComponent component) 当组件被渲染到DOM中之后，findDOMNode返回该React组件实例相应的DOM节点。它可以用于获取表单的value以及用于DOM的测量。 12345678910//当前组件加载完时获取当前DOMimport React,&#123;Component&#125; from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;class App extends Component&#123; componentDidMount()&#123; //this为当前组件实例 const dom = ReactDOM.findDOMNode(this); &#125; render()&#123;&#125;&#125; findDOMNode只对已经挂载的组件有效。 render 用于把React渲染的Virtual DOM渲染到浏览器的DOM当中。 12345ReactComponent render( ReactElement element, DOMElement container, [function callback]) 该方法把元素挂载到container中，并返回element实例（refs引用）。如果是无状态组件，render会返回null，当组件装载完毕时，callback就会被调用。 再次更新时，React不会把组件重新渲染，而是用DOM diff算法做局部更新。 ReactDOM的不稳定方法 有两种不稳定方法 refs 组件中特殊的prop，可以附加到任何一个组件上。组件被调用时会指向一个实例，而refs会指向这个实例。 可以是一个回调函数，这个回调函数会在组件挂载之后立即执行。 refs同样支持字符串，对于DOM操作，不仅可以使用findDOMNode获得该组件DOM，还可以使用refs获得组件内部的DOM。 React之外的DOM操作 React的 声明式渲染机制把复杂的DOM操作抽象为简单的state和props的操作，因此避免了很多直接的DOM操作。不过，仍有一些DOM操作是React无法避免的。","categories":[{"name":"前端","slug":"前端","permalink":"http://wlfsmile.win/categories/前端/"}],"tags":[{"name":"react","slug":"react","permalink":"http://wlfsmile.win/tags/react/"}]},{"title":"深入react技术栈-1","slug":"深入react技术栈-1","date":"2017-04-10T12:24:24.000Z","updated":"2017-04-10T12:27:07.607Z","comments":true,"path":"year/04/10/深入react技术栈-1/","link":"","permalink":"http://wlfsmile.win/year/04/10/深入react技术栈-1/","excerpt":"第一章（基本介绍、JSX、React组件） react是Facebook开源在github上的JavaScript库。把用户界面抽象成一个个组件。引用了JSX语法","text":"第一章（基本介绍、JSX、React组件） react是Facebook开源在github上的JavaScript库。把用户界面抽象成一个个组件。引用了JSX语法 虚拟DOM react把真实DOM树转成JavaScript对象树（虚拟DOM）。 虚拟DOM提升了react的性能。还方便和其他平台集成。 react承载了构建HTML结构化页面的职责。是通过创建与更新虚拟元素来管理整个虚拟DOM。JSX 用意在于通过加入增强语法，使JavaScript更快、安全、简单。 虚拟元素的构建和更新都是在内存中完成的，并不会真正的渲染到DOM中去。 react创建的虚拟元素分为DOM元素和组件元素两种。分别对应着原生DOM元素与自定义元素。 因为元素有公共的表达方法，我们就可以让元素们彼此嵌套或混合。这种层层封装的组件元素就是所谓的react组件，最终可以用递归渲染的方式构建出完全的DOM元素树。 JXS是将HTML语法直接加入到JavaScript代码中，再通过翻译器转换到纯JavaScript后由浏览器执行。JSX基本语法 JSX是类XML语法的ECMAScript扩展，可以说，JSX基本语法被XML囊括，但也有些许不同 XML基本语法+标签可以任意嵌套。可以清晰地看到DOM树状结构及其属性。 123456789const List = () =&gt;( &lt;div&gt; &lt;Title&gt;title&lt;/Title&gt; &lt;ul&gt; &lt;li&gt;list&lt;/li&gt; &lt;li&gt;list&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;); 注意 定义标签时，只允许被一个标签包裹。 标签一定要闭合。元素类型 HTML标签首字母为小写，对应DOM元素；反之，则对应组件元素。 依赖的组件中元素不再出现组件元素，就可以将完整的DOM树构建出来。 JSX还可以通过命名空间的方法使用组件元素，可以解决组件命名冲突和对一组组件进行归类。 注释 JSX中未定义注释的转换。不过在一个组件的子元素位置使用注释要用{}包起来。123456789const App=&#123; &lt;Nav&gt; &#123;/* 节点注释*/&#125; &lt;Person /* 多行 注释 */ name=&#123;window.name&#125; &lt;/Nav&gt;&#125; 元素属性在JSX中，DOM和组件元素都有属性。 DOM元素的属性是标准规范化属性，除了class和for。 class——className for——HTMLFor 组件元素的属性是完全自定义的属性。 Boolean属性 省略Boolean属性值会导致JSX任务bool值设为了true。 展开属性 如果事先不知道设置那些pros，最好不要设置。可以用ES6 rest/spread特性来提高效率123456//可以将const data = &#123;name:&apos;foo&apos;,value:&apos;bar&apos;&#125;;const component = &lt;Component name=&#123;data.name&#125; value=&#123;data.value&#125; /&gt;;//写为const data = &#123;name:&apos;foo&apos;,value:&apos;bar&apos;&#125;;const component = &lt;Component &#123;...data&#125;/&gt;; 自定义HTML属性 + 如果在JSX中往DOM元素中传入自定义属性，react不会渲染。若要使用，要使用data-前缀。 + 在自定义标签中任意属性都是被支持的。 + 以aria-开头的网络无障碍属性同样可正常使用。 JavaScript属性表达式 属性值要使用表达式，只要用{}替换””即可。HTML转义 React组件 组件封装的基本思路是面向对象思想。交互基本上以操作DOM为主，逻辑上是结构上需要改变哪里，我们就操作哪里。 规范化标准组件 基本的封装性。 简单的生命周期呈现。 明确的数据流动。数据指的是调用组件的参数。React组件的构建 react组件由属性（pros）、状态（state）以及生命周期方法三个部分组成。 react自定义元素是库自己建成的 react渲染过程包含模板的概率，及JSX react组件的实现均在方法与类中。所有可以相互隔离，但不包括样式 react引用方式遵循ES6 module标准React组件的构建方法 React基本上由组件的构建方式、组件内的属性状态与生命周期方法组成。 React组件的构造方法：React.createClass、ES6 classes和无状态函数。 React.createClass 是Reactz=最传统、兼容性最好的方法。 1234567891011121314151617const Button = React.createClass(&#123; getDefaultProps()&#123; return&#123; color:&apos;blue&apos;, text:&apos;Confirm&apos;, &#125;; &#125;, render()&#123; const &#123;color,text&#125; = this.props; return( &lt;button className=&#123;`btn btn-$&#123;color&#125;`&#125;&gt; &lt;em&gt;&#123;text&#125;&lt;/em&gt; &lt;/button&gt; ); &#125;&#125;); ES6 classes 写法是通过ES6标准的类语法的方式来构建方法 123456789101112131415161718import React,&#123;Component&#125; form &apos;react&apos;;class Button extends Component&#123; constructor(props)&#123; super(props); &#125; static defaultProps = &#123; color:&apos;blue&apos;, text:&apos;Confirm&apos;, &#125;; render()&#123; const &#123;color,text&#125; = this.props; return( &lt;button className=&#123;`btn btn-$&#123;color&#125;`&#125;&gt; &lt;em&gt;&#123;text&#125;&lt;/em&gt; &lt;/button&gt; ); &#125;&#125; 无状态函数1234567function Button(&#123;color=&apos;blue&apos;,text=&apos;Confirm&apos;&#125;)&#123; return( &lt;button className=&#123;`btn btn-$&#123;color&#125;`&#125;&gt; &lt;em&gt;&#123;text&#125;&lt;/em&gt; &lt;/button&gt; );&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://wlfsmile.win/categories/前端/"}],"tags":[{"name":"react","slug":"react","permalink":"http://wlfsmile.win/tags/react/"}]},{"title":"极客官网项目制作总结","slug":"极客官网项目制作总结","date":"2017-02-27T12:15:20.000Z","updated":"2017-02-27T13:36:44.001Z","comments":true,"path":"year/02/27/极客官网项目制作总结/","link":"","permalink":"http://wlfsmile.win/year/02/27/极客官网项目制作总结/","excerpt":"这篇文章是为了总结了一下这个寒假的寒假作业——极客网工作室官网制作","text":"这篇文章是为了总结了一下这个寒假的寒假作业——极客网工作室官网制作 前期准备这个官网是主要制作我们工作室一个展示的官网。其中分为三个小组，有前端、后台。而我，也恰巧使我们小组的组长。这也是我在这个寒假做的唯一的一件大事情。 首先，是小组进行了讨论，主要是针对需求文档，包括一些基本信息，基本功能实现、网页设计制作、人员分配等问题（因为我们只是寒假放假之后短暂的停留几天，都会各自回家，所以详细的讨论更分工就显得尤为重要）。 大致讨论内容 网页模式：长网 本机服务器：MySQL 工具：coding、、RAP 规范：《百度前端代码规范》 写代码命名加上自己的首字母+下划线，如税小豪（S_） 长网页每个人负责的版块用一个整的\\括起来 实现技术：HTML、CSS、JavaScript/JQuery、Java、Spring MVC、Ajax 前后端版块实现 前端展示页 后台数据库 后台管理界面 功能： 导航栏：首页、工作室简介、成员介绍、毕业去向、加入我们 主页：背景大图+logo+轮播 工作室简介 成员介绍(交互) 交互数据：name(成员姓名)、 img(照片地址) 、grade(年级) 、direction(技术方向 )、motto(格言) 毕业去向(交互) company(公司) 加入我们(交互) 传给后台：name(姓名) 、shoolName(学院) 、major(专业) 、studentId(学号) 、direction(技术方向) 前期准备的问题 因为我们是在学校进行讨论，准备回家后做，可是这样就出现了严重的时间效率拖延问题，以至于是最后大家提前回学校进行制作的。 作为组长，我没有做好详细的分配，是我的失责 还有就是网页样式制作的准备不够，造成了我们后期对样式修改的程度比较大 工具的使用没有正确。虽然用的是coding，可是前期框架没有搭好，在后期也造成了一定问题 正式制作正式制作，我主要负责了后台管理界面和前端界面的毕业去向这一块。 主要技术使用 这次我只是单独说一下我负责的那块的技术使用。 HTML、css 两样进行了基本样式的制作 用简单的css3 进行了一些动画效果的制作 用jQuery写的ajax进行交互 用ajax进行动态请求分页 这次我用的最多的就是ajax的交互使用，所以说，我更多的是增加了对ajax的一些熟悉度和他的基本原理。 制作中的问题 因为之前我几乎没有接触过css3，所以并未处理好css3动画效果的兼容性 ajax的代码量太大，没有做到很好的优化代码量，不过在后期的制作中，我注意到了这一点 ajax的异步请求问题。前期通过了一个ES6中的promise使其纵向加载。后期也可以通过写在ajax里面进行ajax来解决问题 代码比较乱，因为我们的代码展示都在同一个页面，虽然前期说了代码规范，不过后来还是出现了一些问题，而且也忘了JavaScript中将代码封装在立即执行函数中 总结这次项目是一个不大不小的项目。作为组长的我在分配以及调节方面都有不可推卸的责任，这也是我之后制作项目的一个警戒。不过看到项目完工，其实也有一种莫名的自豪感，哈哈哈，还是觉得实实在在敲代码比较好。。一个寒假，原本的学习计划都没有好好执行。QAQ，新学期，我要进行新学习咯，加油，好好学习！","categories":[{"name":"前端","slug":"前端","permalink":"http://wlfsmile.win/categories/前端/"}],"tags":[{"name":"技术总结","slug":"技术总结","permalink":"http://wlfsmile.win/tags/技术总结/"}]},{"title":"纪念一下做程序员这半年","slug":"纪念一下做程序员这半年","date":"2017-01-15T16:06:36.000Z","updated":"2017-02-27T12:24:56.252Z","comments":true,"path":"year/01/16/纪念一下做程序员这半年/","link":"","permalink":"http://wlfsmile.win/year/01/16/纪念一下做程序员这半年/","excerpt":"这篇文章只是仅仅为了纪念一下我做程序员的半周年 什么时候开始决定做程序员呢，具体的心理变化可能没有那么清楚，不过大概的事件变化还是知道的。","text":"这篇文章只是仅仅为了纪念一下我做程序员的半周年 什么时候开始决定做程序员呢，具体的心理变化可能没有那么清楚，不过大概的事件变化还是知道的。 2016-07-16 2016年的夏天，刚好结束了大一的懵懂迷茫的日子，从七月初开始的军训也进入尾声，这一天的太阳对于一个已经经历过半个多月的被太阳暴晒的我而言，貌似没有那么狠毒。今天是军训结束的那一天，也是我踏进极客网的第一天。今天开始了所谓的宣讲会，我也不知道我是抱着什么样的心态踏进这里的。可能是为了不让自己的大学变得那么碌碌无为，无所事事，或许也是为了所谓了以后的毕业后的社会生活。可是不管怎样，我来了，也从未想主动离开。模模糊糊记得那时候大二大三的学姐学长们的话，模模糊糊的记得刘老师的只言片语，模模糊糊的记得我坐在第二排右边的第二个位置。那时候的我还对程序员的一切感到陌生但并未恐惧。 2016-7-17——2016-9(HTML和CSS和初步了解JavaScript) 这是大学的第一个暑假，因为所谓的心中抱负，所谓的程序员的理想，留在了学校。这也是我开始代码生活的第一个假期。第一次做网页做的是叫一个“恭贺新春”的网页，现在看来完全小菜一碟，可是当时我的内心可是崩溃的好么。对于一个小白的不能再小白的我而言，一个网页对于我而言也是很痛苦的。完全懵逼。不过好在我通过我不知道是什么的毅力给他做出来了，那时候没有讲究所谓的代码规范，命名规范，不要用表格布局什么的，连编辑器都没有讲究。反正就是我现在都忘了我是怎么把它做好的。现在那个成品在我的电脑里面，我都不忍心去打开它，总觉得那么的那啥。后来又陆陆续续的做了一个页面跟五个组件，就完全适应了某种模式。而且，也跟工作室的大家混熟了。现在想起来，在那个暑假最好的就是在工作室占据了自己的一席之地，慢慢的把自己的生活用品拿到了工作室，慢慢的，这里变成了我大学除了寝室之外最熟悉最有我生活气息的地方了。而最熟悉的话，莫过于室长大人每天说的代码规范和看那两本他所“代言”的两本书，虽然我在暑假结束都没有看那两本书，而是在暑假结束之后看的。 2016-9——2016-11(JavaScript和JQuery)这两个月主要是学习了JavaScript和jQuery。主要是看了《JavaScript高级程序设计》和《锋利的jQuery》这两本书，对于JavaScript高程就是看了一遍，做了十几篇类似于笔记的博客。而对于jQuery，做过几篇笔记，也用jQuery写了一个比较复杂的优设网。这一段时间也是学习的一个缓慢期。主要都是通过看书来学习，可能是我毅力不够，看书对于我而言也是比较懵逼的，特别是看完一遍高程之后的一脸懵逼，想想还真好笑。 2016-10 这个月要单独列出来说一下咯。哈哈哈，这个月工作室联盟，开始了对大一的 新生招新，想想他们真好，可以大一就开始接触技术。而自己确是大二了才开始。而且也开始那第一次的培训，由室长大大亲自操刀。 2016-11——2016-12(校园博览会项目制作) 这一个多月，是我这学期最忙也是最充实的一个月。即使中间有那么一点的不开心与不理解，不过最后的结果还是挺好的。这一个月也让我成长了很多，也许也在工作室某些人的心里突然变得比较厉害起来，但是也只有自己知道自己是几斤几两，其实心理压力还是蛮大的。这个项目本来一开始并不是我在参与，可是由于种种原因，我也是在小半路上加进去了。学到的最多的可能就是交互的功能的使用。一开始其实我没有主动去接这个项目，更多的是因为害怕，我怕自己的能力太弱，不敢去接。后来我也懂了，有些东西，真的要靠自己去争取的，不然真的很难去获得这个机会并去成长，也不要害怕自己能力不够，能力，就是在实践中获取的。 2016-12——2017-1 这一个月貌似对代码的感染力没有那么大了，基本上都是被四级考试、期末考试这两样东西所占据，不过在期末考试之前，我开始入门看了一部分的ES6，不够可惜的是，没有总结的博客。而且，看的也不多，看过的一些东西，在期末完了之后，发现自己也忘记了，只有从头开始了。 2017-1——2017-1-16好了，也就是到今天了，刚刚好半年。做程序员的这半年，也许，从某种角度而言，这半年，我也不算真正的程序员，只是从一个职业小白变成了半黑半白的我，还多亏学姐学长们的帮助。未来的路还很长，当然，我会坚持做程序员。毕竟，这是我上大学了，坚持了那么久的事情。在很多人眼中变成了一个刻苦认真，为自己目标好好奋斗的励志青年。未来。我更要好好的加油。加油吧，自己！ 最后总结一下这半年的成果 三个网页 恭贺新春 卓一企管 优设网 五个组件 表单验证 Tab选项卡 轮播 弹出登录框 json分页 两个项目 校园博览会 极客网官网（还在进行中） 工具使用 github 博客园写了22篇博客 coding sublime 谷歌调试器 coding 用Hexo搭建了自己的博客 简书 RAP 阅读书籍 《精通CSS》 《编写高质量代码》 《JavaScript高级程序设计》 《锋利的jQuery》 《ES6》 看的书籍可能不是很多。在这个寒假我还会再看，会比较偏向学习node，夯实JavaScript的知识，还有完成工作室官网。加油吧，向未来跨进。","categories":[{"name":"日常","slug":"日常","permalink":"http://wlfsmile.win/categories/日常/"}],"tags":[{"name":"纪念","slug":"纪念","permalink":"http://wlfsmile.win/tags/纪念/"}]},{"title":"markdowm语法总结","slug":"markdowm语法总结","date":"2017-01-14T06:23:59.000Z","updated":"2017-01-16T11:14:34.192Z","comments":true,"path":"year/01/14/markdowm语法总结/","link":"","permalink":"http://wlfsmile.win/year/01/14/markdowm语法总结/","excerpt":"对一些简单markdown的语法理解 这也是我第一次用markdown语法写的文章，还是有很多不足","text":"对一些简单markdown的语法理解 这也是我第一次用markdown语法写的文章，还是有很多不足 【前提概要】对于一个markdown小白来总结这篇文章，我理解的最深刻的就是，HTML与markdown语法之间的联系。简而言之，HTML不能使用markdown的语法，但是markdown中支持在HTML中的语法使用。所有我一开始用的HTML语法来写的github的README.md文档达到了我想要的效果 ，比如\\&lt; p&gt;或者\\&lt; img&gt;标签，也可以用来作为markdown中的行段落和插入图片。 【段落和换行】要写一篇文章的话，对于段落感跟换行是必须的，可以用HTML中的\\&lt; br&gt;标签进行换行， 但在markdown中，也可以用两个或两个以上的空格加回车键，就可以换好行了。 【标题】Markdown 支持两种标题的语法，类 Setext 和类 atx 形式。类 Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题）。相比于类Setext形式，我更喜欢用类atx形式，相比也比较简单，直接在标题前面加上#即可，几号标题加几个#即可（1到6个）。 【区块引用 Blockquotes】在文字开头添加“&gt;”表示区块引用（块注释） 【斜体和粗体】在需要斜体的文字两端用”*“或者”_“夹起来，而如要粗体，则用两个”*“或者”_“夹起来。 【无序与有序列表】在文字开头添加(*, +, and -)实现无序列表。但是要注意在(*, +, and -)和文字之间需要添加空格。(一个文档中最好只是用一种无序列表的表示方式)，而有序列表在使用数字后面加上句号和空格即可。 【链接】实现链接一共有两种基本方式：内联和引用方式。内联：在链接的文字外加上[],而在[]外加上(里面是链接的地址)，如：这篇文章主要来自markdown语法。引用：这篇文章主要来自[markdown语法][1]，[第二个][2][1]: http://www.appinn.com/markdown/ “markdown”[2]: http://www.appinn.com/markdown/ “markdown”其中”markdown”表示鼠标移到链接的文字上去，会显示出来的内容，如：引用：这篇文章主要来自markdown语法，第二个 【插入图片】插入图片的方式跟链接的方式类似。内联方式：![alt text](/path/to/img.jpg “Title”)引用方式：![alt text][id][id]: /path/to/img.jpg “Title” 【代码框】有两种方式，第一种是在一些比较简单的代码中，可以直接使用` &lt; blockquote&gt;`来实现。第二种是大片文字需要实现代码框。使用Tab或四个空格。 【脚注】hello[^hello][^hello]: hi效果为：hello^hello 【下划线】在空白行下方添加三条“-”横线。","categories":[{"name":"前端","slug":"前端","permalink":"http://wlfsmile.win/categories/前端/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://wlfsmile.win/tags/markdown/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-01-12T11:09:45.109Z","updated":"2017-01-14T05:26:38.943Z","comments":true,"path":"year/01/12/hello-world/","link":"","permalink":"http://wlfsmile.win/year/01/12/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"第二次讨论","slug":"第二次讨论","date":"2016-10-27T11:38:13.000Z","updated":"2017-01-16T12:26:40.536Z","comments":true,"path":"year/10/27/第二次讨论/","link":"","permalink":"http://wlfsmile.win/year/10/27/第二次讨论/","excerpt":"这些是小组第二次讨论，主要讨论了响应式设计、布局、css性能优化、css预处理","text":"这些是小组第二次讨论，主要讨论了响应式设计、布局、css性能优化、css预处理 【响应式设计】集中创建页面的图片排版大小，可以智能地根据用户行为以及使用的设备环境（系统平台、屏幕尺寸、屏幕定向等）进行相对应的布局。响应式布局：meta标签的实用：设置布局宽度等于设备宽度，布局viewport等于度量viewport&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt; 【【布局】】【水平居中】 text-align和inline-block的联合使用：text-align属性：通过指定行框与哪个点对齐，从而设置\u001f块级元素内文本的水平对齐方式。（从而child为文本行内元素，parent为块状元素，可以通过display来设置）。 .parent{text-align: center;} //父元素 .child{display: inline-block;}//子元素 不过此方法兼容性比较好，IE浏览器接收。不过代码较多，同时要设置父元素和子元素。 使用margin：0 auto设置 .child{width:100px;margin:0 auto;}//必须要有宽度 margin设置的是块级元素的居中。兼容性好，不过需要设置宽度。 display：table设置 .child{display:table;margin:0 auto;} 此方法只需对自身进行设置，代码简短。不过在IE6、7上，需要进行调整。 使用绝对定位 .parent{position:relative;} /*或者实用margin-left的负值为盒子宽度的一半也可以实现，不过这样就必须知道盒子的宽度，但兼容性好*/ .child{position:absolute;left:50%;transform:translate(-50%);} transform：translate。移动transform在translation的方向和距离。简单的说，向某方向移动物体多少距离。不过这个方法兼容性不好，要IE9 以上。 【垂直居中】 vertical-align方法 /*第一种方法*/ .parent{display:table-cell;vertical-align:middle;height:20px;} /*第二种方法*/ .parent{display:inline-block;vertical-align:middle;line-height:20px;} 在使用vertical-align的时候，由于对齐的基线是用行高的基线作为标记，故需要设置line-height或设置display:table-cell。 使用绝对定位 .parent{position:relative;} .child{positon:absolute;top:50%;transform:translate(0,-50%);} 注意与水平居中的区别 【水平垂直居中】 利用vertical-align,text-align,inline-block实现 .parent{display:table-cell;vertical-align:middle;text-align:center;} .child{display:inline-block;} 使用绝对定位 .parent{position:relative;} .child{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);} 由上可知，绝对定位可以实现任何方式的居中，不过还要考虑兼容性问题。 【多列布局】 左列定宽，右列自适应： 使用float+margin .left{float:left;width:100px;} .right{margin-left:100px;} 经试验，如果不用margin的话，必须设置高度。IE6会有3px的bug使用table实现 .parent{display:table;table-layout:fixed;width:100%;} .left{display:table-cell;} .right{width:100px;display:table-cell;} 两列定宽，一列自适应 使用margin+float利用float+overflow实现 .left,.center{float:left:width:200px;} .right{overflow:hidden;} 利用table实现 两侧自适应，中间定宽（网页布局常用） 使用margin+float .left{width：100px;float:left;} .center{float:left;width:100%;margin-right:-200px;} .right{width:100px;float:right;} 利用table实现 一列不定宽，一列自适应 利用float+overflow实现 .left{float:left;background-color: red;height: 100px;} .right{background-color: blue;overflow: hidden;height: 100px;} 不需要设定高度。会自适应。 多列式分布 div+float 九宫格布局 div+table 【css性能优化】 模块化：让代码高度重用，提高开发效率。模块与模块之间尽量不要包含相同的部分，如果有，提取出来，拆分成一个独立的模块。 css命名：用英文。大小驼峰、下划线等。驼峰表示区别不同单词，下划线表示从属关系。避免重复命名，自己的代码前加上属于自己的前缀。 class的使用：多组合，少继承。 上下margin处理：如果不确定模块的上下margin特别稳定，最好不要将它写在模块的类里，而是使用类的组合，单独为上下margin挂用于边距的原子类（如mt10、mb20）。模块最好不要混用margin-top和margin-bottom，统一使用某一个。 低权重原则：避免滥用自选择器。当不同选择符的样式设置有冲突时，会采用权重高的选择符设置样式。选择符权重相同，为就近原则。 权重原则：HTML标签为1（如p），class为10，id为100。css选择符保证权重尽可能低。使用子选择器，会增加css选择符的权重。新添class更利于维护。 css sprite技术：将网站的多张背景图片合并到一张大图上。利用background-position属性来展示我们需要的部分,图片加载会发出HTTP请求，而使用css sprite就减少了HTTP请求次数。减轻服务器压力。只能合并背景图片。对于横向和纵向都平铺的图片，不能使用css sprite，只能或横向，或纵向。排版要尽量紧凑。缺点：降低开发效率和增大维护难度，是否使用取决于网站流量。 css常见问题： 编码风格： 多行式可读性强，不过会增大css文件大小，一行式可读性较差，不过利于提高开发速度，减小css文件大小。推荐一行式。 id和class： -同一网页，相同id只能出现一次，但是class无限制。id的权重大于class。不过原生JS提供getElementId()方法，不支持class。使用id会限制网页的扩展性。一般情况下，建议尽量使用class，少用id。 css hack： IE条件注释法（兼容性最好，增加了开发和维护成本） 选择符前缀法（增强了可维护性，不过兼容性欠佳，不能用于内联样式） 样式属性前缀法（集合度更高，代码更加精简，可维护性更强，但存在兼容风险，可用于内联样式） 解决超链接访问后hover样式不出现的问题： a标签四种状态的排 序问题，love hate原则 ，即l(link)ov(visited)e h(hover)a(active)te。 haslayout： -IE浏览器的专有属性，用于css的解析引擎。很多bug都因为haslayout没有被自动触发。最好的解决方法：zoom。 块级元素和行内元素： 使用display转换。 IE6、7不支持display：inline-block。 relative、absolute和float：不要滥用。【css预处理】用一种专门的编程语言，为 CSS 增加了一些编程的特性，将 CSS 作为目标生成文件，然后开发者就只要使用这种语言进行编码工作。","categories":[{"name":"前端","slug":"前端","permalink":"http://wlfsmile.win/categories/前端/"}],"tags":[{"name":"css","slug":"css","permalink":"http://wlfsmile.win/tags/css/"}]},{"title":"第一次讨论","slug":"第一次讨论","date":"2016-10-15T11:17:03.000Z","updated":"2017-01-16T11:33:36.898Z","comments":true,"path":"year/10/15/第一次讨论/","link":"","permalink":"http://wlfsmile.win/year/10/15/第一次讨论/","excerpt":"这篇博客写于 2016-10-15 这个主要是我们前端小组第一次讨论的内容，行内与块级、浮动与清除浮动、定位、兼容性处理。其中大多内容都是我从网上收集来的。还是需要有自己的想法。感觉这次讨论还是挺有一定的效果的。至少我把有一些内容更加完整跟清晰化了。","text":"这篇博客写于 2016-10-15 这个主要是我们前端小组第一次讨论的内容，行内与块级、浮动与清除浮动、定位、兼容性处理。其中大多内容都是我从网上收集来的。还是需要有自己的想法。感觉这次讨论还是挺有一定的效果的。至少我把有一些内容更加完整跟清晰化了。 【行内元素和块级元素】块级元素：div , p , form, ul, li , ol, dl， address, fieldset, hr, menu, table行内元素：span, strong, em, br, img , input, label, select, textarea, cite可变元素（根据上下文语境而定）：button，applet，del，ifram，ins，map，object，script 区别： 块级元素会独占一行，其宽度自动填满其父元素宽度 行内元素不会独占一行，相邻的行内元素会排列在同一行里，知道一行排不下，才会换行，其宽度随元素的内容 而变化 块级元素可以设置 width, height属性，行内元素设置width, height无效【注意：块级元素即使设置了宽度，仍然是独占一行的】 块级元素可以设置margin 和 padding. 行内元素的水平方向的都产生边距效果，但是竖直方向的都不会产生边距效果。（水平方向有效，竖直方向无效）。将display设为block，可以让行内元素表现像块级元素。line-block在IE6下有问题。 【浮动和清除浮动（闭合浮动）】高度塌陷：元素含有浮动元素—破坏inline box—破坏line box—没有高度—塌陷。当标签里面的元素只要样子没有实际高度时就会塌陷。 若浮动对象有负边界，浮动对象可能会浮到其所在父对象外边。 若较宽的子盒子有一个较窄的父盒子中拥有浮动属性，不会影响父盒子宽度，子盒子越到父盒子外，父盒子不会有文本流浮动，而子盒子会覆盖在上。 父盒子为自动高度或不设，子盒子拥有浮动，并高度超过了父盒子（解决方法：加入clear:both） 清除浮动 IE下：使元素haslayout。非IE下：通常使用overflow:hidden。 方法： 直接添加clear:both（不推荐）； overflow+zoom：有局限性，margin为负定位或是负的绝对定位。.fix{overflow:hidden;zoom:1;}。 after+zoom：.fix{zoom:1;} .fix:after{display:block;content:”.”;clear:both;line-height:0;visibility:hidden;} 方法： 让容器也浮动。 设置容器overflow为auto或hidden（有副作用）。 【定位】基本方式：static（默认定位方式）、relative、absolute。relative：相对定位，相对于原来的位置，但是原来的位置仍然保留。absolute：绝对定位，相对于最近的非标准流定位，原来的位置消失，被最后边的位置所顶替。fixed：固定定位。定位机制是由普通流、浮动、绝对定位三种组成。只要父级元素设置了position并且不是static，那么设定了absolute的子元素，即以此为包含块（最近的）。绝对定位元素定位的参照物使其包含块，即相对于包含块进行定位，不一定是其父元素。 【兼容性处理】CSS hack：为了页面统一，针对不同浏览器或不同版本写出可解析的css样式，把这个针对不同浏览器/版本写的css过程叫做css hack。 问题： DOCTYPE 影响 CSS 处理 ； FF: 设置 padding 后， div 会增加 height 和 width， 但 IE 不会， 故需要用 !important 多设一个 height 和 width 。FF: 支持 !important， IE 则忽略,可用 !important 为 FF 特别设置样式 在mozilla firefox和IE中的BOX模型解释不一致导致相差2px解决方法： div{margin:30px!important;margin:28px;} 注意这两个margin的顺序一定不能写反，!important这个属性IE不能识别，但别的浏览器可以识别。 浏览器差异： ul和ol列表缩进问题 消除ul、ol等列表的缩进时，样式应写成：{list-style:none;margin:0px;padding:0px; } 其中margin属性对IE有效，padding属性对FireFox有效。 css透明度 IE：filter:progid:DXImageTransform.Microsoft.Alpha(style=0,opacity=60)。 FF：opacity:0.6。最好两个都写，并将opacity属性放在下面。 css圆角问题 IE：IE6及以下不支持圆角。 FF：支持border-radius。 firefox不支持hand，但ie支持pointer ，两者都是手形指示。 最好统一使用pointer。 浏览器bug： IE的双边距：设置为float的div在IE下设置margin会加倍。 解决方法：在div面加上display:inline; IE选择器空格bug：在IE中，处理伪类时，如果伪类的名称中带有连字符“-”，伪类名称后面就得跟一个空格，不然定义无效。在FF中无影响。【其他】 display:none和visiblity:hidden的区别：display:none，不占位，相当于完全消失。而visiblity:hidden，占位，相当于只是把它给隐藏掉。","categories":[{"name":"前端","slug":"前端","permalink":"http://wlfsmile.win/categories/前端/"}],"tags":[{"name":"css","slug":"css","permalink":"http://wlfsmile.win/tags/css/"}]}]}